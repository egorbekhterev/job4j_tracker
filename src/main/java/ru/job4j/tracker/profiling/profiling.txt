VM options: -Xlog:gc* -XX:+UseG1GC;
#jmap
В память добавлено 111111 заявок:
![](jmap_after_adding_requests.png)
Из памяти удалены все заявки:
![](jmap_after_deleting_all_requests.png)
После добавления заявок наблюдается заполнение HeapCharBuffer;
Для создания объектов Item в большом количестве зайдествуются классы String и StringBuilder,
LocalDateTime и DateTimePrintContext;

VM options: -Xlog:gc* -XX:+UseG1GC;
#jstat
![](jstat_while_adding_requests.png)
По мере добавления большого объема заявок наблюдается использование объектов из Survivor Space 1,
увеличивается вместимость Eden, при этом увеличивается и использование объектов из Eden. Аналогичная ситуация происходит
для Old Space, Metaspace, Compressed class . Суммарное время сборки мусора = 8.614 мс, для Young Generation = 6 мс.
Minor GC произведено 83 раза, Major GC - 8 раз. После Major GC наблюдается резкое падение Eden capacity и Eden utilization до 0.
Также упала вместимость Survivor Space 1. Перед первым вызовами Minor GC наоборот наблюдается равномерное распределение
памяти по всем ее участкам (Нагружены все, кроме S0).

VM options: -Xlog:gc* -XX:+UseSerialGC -Xmx12m -Xms12m;
#jconsole
![](jConsole_application.png)
При добавлении 111111 заявок наблюдается OutOfMemoryError : Java Heap Space, резкое увеличение нагрузки на процессор.
Далее производим постепенное добавление 3333 заявок в моменты уменьшения нагрузки на Heap, постепенно приближаясь
к проговому занчению в 12,2 Mb. Каждую итерацию больше объектов попадает в Old Generation, поэтому после чистки GC каждое
новое значение локальных минимальных экстремумов увеличивается.
Снижение количества используемых threads вероятнее всего говорит об оптимизации работы приложения со стороны JVM.
Количество используемых классов незначительно возросло с первым добавлением заявок.
Нагрузка на процессор была максимальной в момент запуска приложения. При добавлении заявок так же наблюдалось незначительное
повышение нагрузки на CPU.

